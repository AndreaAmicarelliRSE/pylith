#!/usr/bin/env python
#
# ----------------------------------------------------------------------
#
# Brad T. Aagaard, U.S. Geological Survey
# Charles A. Williams, GNS Science
# Matthew G. Knepley, University of Chicago
#
# This code was developed as part of the Computational Infrastructure
# for Geodynamics (http://geodynamics.org).
#
# Copyright (c) 2010-2017 University of California, Davis
#
# See COPYING for license information.
#
# ----------------------------------------------------------------------
#
# Generate CUBIT/Trelis journal file to create slab surface from Slab
# 1.0 contours.
#
# We decimate the contours from Slab 1.0 in order to reduce the
# complexity of the slab geometry so that the mesh generation is
# faster.
#
# The Slab contours can be downloaded from:
# https://earthquake.usgs.gov/data/slab/models.php
#
# The reference for the Slab 1.0 model is:
#
# Hayes, G. P., D. J. Wald, and R. L. Johnson (2012), Slab1.0: A
# three-dimensional model of global subduction zone geometries,
# J. Geophys. Res., 117, B01302, doi:10.1029/2011JB008524.

import numpy
from collections import OrderedDict

# ----------------------------------------------------------------------
class JournalFile(object):
    """JournalFile object for writing CUBIT/Trelis journal file.
    """
    
    def __init__(self, filename):
        """Constructor.
        """
        self.file = open(filename, "w")
        return
    
    
    def writeHeader(self):
        """Write header for journal file.
        """
        self.file.write("# CUBIT/Trelis journal file generated by generate_slabtop.py\n" \
                        "#\n" \
                        "# Create an ACIS NURBS surface from contours.\n" \
                        "#\n" \
                        "reset\n\n")
        return

    def writeTrailer(self):
        """Write trailer for journal file.
        """
        self.file.write("# Create surface from curves.\n" \
                        "create surface skin curve all\n" \
                        "delete curve all\n\n" \
                        "# Save surface to ACIS file for later use.\n" \
                        "export acis 'slabtop_surf.sat' overwrite\n")
        return
    
    
    def writeContour(self, points):
        """Write contour to journal file.
        """
        self.file.write("# Contour\n")
        self.file.write("create vertex x %12.6e y %12.6e z %12.6e\n" % tuple(points[0]))
        self.file.write("${pBegin=Id('vertex')}\n")
        for pt in points[1:]:
            self.file.write("create vertex x %12.6e y %12.6e z %12.6e\n" % tuple(pt))            
        self.file.write("${pEnd=Id('vertex')}\n"\
                        "create curve spline vertex {pBegin} to {pEnd} delete\n\n")
        return


    def close(self):
        self.file.close()
        self.file = None
        return
    
    
# ----------------------------------------------------------------------
class SlabContoursFile(object):
    """SlabContourFile object for reading contours from a Slab 1.0 contour file..
    """

    def __init__(self, filename):
        self.filename = filename
        return
    

    def read(self):
        """Read contours from Slab 1.0 file.
        """
        with open(self.filename, "r") as file:
            lines = file.readlines()
            contours = {}
            points = []
            key = None
            for line in lines:
                if line.strip() == "END":
                    contours[key] = points
                    points = []
                    continue
                if len(line.split()) == 1:
                    key = int(line)
                    continue
                pt = map(float, line.strip().split())
                points.append(pt)
        # Sort contours by key (depth)
        self.contours = OrderedDict(sorted(contours.items(), key=lambda x: x[0])).values()
        

# ----------------------------------------------------------------------
class ContourApp(object):
    """ContourApp object for top-level application workflow.
    """
    
    def __init__(self):
        """Constructor.
        """
        self.sfilename = None
        self.jfilename = None
        self.pointsStride = 1
        return

    
    def run(self):
        """Open Slab 1.0 input file and journal output file and loop over
        contours.
        """
        jfile = JournalFile(self.jfilename)
        jfile.writeHeader()

        sfile = SlabContoursFile(self.sfilename)
        sfile.read()

        for contour in sfile.contours:
            points = self._decimate(contour)
            self._toXYZ(points)
            jfile.writeContour(points)
        jfile.writeTrailer()
        jfile.close()
        return


    def _decimate(self, points):
        """Decimate the number of points in a contour.
        """
        pointsD = numpy.array(points[::self.pointsStride], dtype=numpy.float64)
        if (len(points)-1) % self.pointsStride:
            pointsD = numpy.vstack((pointsD, numpy.array([points[-1]]),))
        return pointsD

    def _toXYZ(self, points):
        """Transform from geographic coordinates and depth in km to geographic
        projected coordinate system. The coordinate system is imported
        from coordsys.py.

        """
        import coordsys
        coordsys.geoToMesh(points)
        points[:,2] *= 1.0e+3
        return


# ======================================================================
if __name__ == "__main__":
    import argparse

    DESCRIPTION = "Python script to create a CUBIT/Trelis "\
                  "journal file that generates the surface from Slab 1.0."

    parser = argparse.ArgumentParser(description=DESCRIPTION)
    parser.add_argument("--stride", action="store", dest="stride", type=int, default=5)
    parser.add_argument("--journal-filename", action="store", dest="jfilename", default="contours.jou")
    parser.add_argument("--slab-filename", action="store", dest="sfilename", default=None, required=True)
    args = parser.parse_args()

    app = ContourApp()
    app.sfilename = args.sfilename
    app.jfilename = args.jfilename
    app.pointsStride = args.stride
    app.run()

    
# End of file
