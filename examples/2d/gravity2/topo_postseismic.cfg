[pylithapp]

# ----------------------------------------------------------------------
# problem
# ----------------------------------------------------------------------
[pylithapp.timedependent]
progress_monitor.filename = topo_postseismic-progress.txt
formulation = pylith.problems.ImplicitLgDeform

[pylithapp.timedependent.formulation.time_step]
# Define the total time for the simulation and the time step size.
total_time = 2000.0*year
dt = 10*year

# ----------------------------------------------------------------------
# materials
# ----------------------------------------------------------------------
# Crust
[pylithapp.timedependent.materials.crust]
db_initial_stress.label = Initial stress in mantle
db_initial_stress.iohandler.filename = grav_statevars-crust.spatialdb
db_initial_stress.query_type = nearest

# Mantle
[pylithapp.timedependent.materials.mantle]
db_initial_stress.label = Initial stress in mantle
db_initial_stress.iohandler.filename = grav_statevars-mantle.spatialdb
db_initial_stress.query_type = nearest

db_initial_state.label = Initial state in mantle
db_initial_state.iohandler.filename = grav_statevars-mantle.spatialdb
db_initial_state.query_type = nearest

# ----------------------------------------------------------------------
# faults
# ----------------------------------------------------------------------
[pylithapp.timedependent]
interfaces = [fault]

# Set the type of fault interface condition.
[pylithapp.timedependent.interfaces]
fault = pylith.faults.FaultCohesiveKin

# Set the parameters for the fault interface condition.
[pylithapp.timedependent.interfaces.fault]
# The label corresponds to the name of the nodeset in CUBIT.
label = fault
edge = faultedge

# We must define the quadrature information for fault cells.
# The fault cells are 1D (line).
quadrature.cell = pylith.feassemble.FIATLagrange
quadrature.cell.dimension = 1

# The slip time and final slip are defined in spatial databases.
[pylithapp.timedependent.interfaces.fault.eq_srcs.rupture.slip_function]
slip.iohandler.filename = eqslip.spatialdb
slip.query_type = linear
slip.label = Final slip

#slip = spatialdata.spatialdb.UniformDB
#slip.label = Final slip
#slip.values = [left-lateral-slip, fault-opening]
#slip.data = [2.0*m, 0.0*m]

# Slip time is uniform, so use UniformDB for convenience
slip_time = spatialdata.spatialdb.UniformDB
slip_time.label = Slip time
slip_time.values = [slip-time]
slip_time.data = [0.0*year]

# ----------------------------------------------------------------------
# output
# ----------------------------------------------------------------------
# Ground surface
[pylithapp.problem.formulation.output.groundsurf]
writer.filename = output/topo_postseismic-groundsurf.h5

# Domain
[pylithapp.problem.formulation.output.domain]
writer.filename = output/topo_postseismic-domain.h5

# Crust
[pylithapp.problem.materials.crust.output]
writer.filename = output/topo_postseismic-crust.h5

# Mantle
[pylithapp.problem.materials.mantle.output]
writer.filename = output/topo_postseismic-mantle.h5

# Fault
[pylithapp.problem.interfaces.fault.output]
writer = pylith.meshio.DataWriterHDF5
writer.filename = output/topo_postseismic-fault.h5

[pylithapp.problem.formulation]
# The split_fields flag must be specified, so that the PCFIELDSPLIT
# preconditioner can be used. The matrix_type must be set to aij since
# we lose symmetry when splitting. We have turned on the custom
# preconditioner for the Lagrange multiplier degrees of freedom.
#
split_fields = True
matrix_type = aij
use_custom_constraint_pc = True

[pylithapp.petsc]
# The displacements are solved with algebraic multigrid (ML), and
# the fault tractions with a standard Krylov method since we do not
# explicitly form the Schur complement matrix.
#
fs_pc_type = fieldsplit
fs_pc_use_amat =
fs_pc_fieldsplit_type = multiplicative
fs_fieldsplit_displacement_pc_type = ml
fs_fieldsplit_lagrange_multiplier_pc_type = jacobi
fs_fieldsplit_displacement_ksp_type = preonly
fs_fieldsplit_lagrange_multiplier_ksp_type = preonly


# End of file
