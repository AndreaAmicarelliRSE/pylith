[pylithapp]

# ----------------------------------------------------------------------
# problem
# ----------------------------------------------------------------------
[pylithapp.timedependent.formulation.time_step]
# Define the total time for the simulation and the time step size.
total_time = 4000.0*year
dt = 10*year

# ----------------------------------------------------------------------
# materials
# ----------------------------------------------------------------------
# Crust
[pylithapp.timedependent.materials.crust]
db_initial_stress = spatialdata.spatialdb.SimpleDB
db_initial_stress.label = Initial stress in mantle
db_initial_stress.iohandler.filename = gravity_isostatic.spatialdb
db_initial_stress.query_type = linear

# Mantle
[pylithapp.timedependent.materials.mantle]
db_initial_stress = spatialdata.spatialdb.SimpleDB
db_initial_stress.label = Initial stress in mantle
db_initial_stress.iohandler.filename = gravity_isostatic.spatialdb
db_initial_stress.query_type = linear

db_initial_state = spatialdata.spatialdb.SimpleDB
db_initial_state.label = Initial state in mantle
db_initial_state.iohandler.filename = gravity_isostatic.spatialdb
db_initial_state.query_type = linear

# ----------------------------------------------------------------------
# faults
# ----------------------------------------------------------------------
[pylithapp.timedependent]
interfaces = [fault]

# Set the type of fault interface condition.
[pylithapp.timedependent.interfaces]
fault = pylith.faults.FaultCohesiveKin

# Set the parameters for the fault interface condition.
[pylithapp.timedependent.interfaces.fault]
# The label corresponds to the name of the nodeset in CUBIT.
label = fault
edge = faultedge

# We must define the quadrature information for fault cells.
# The fault cells are 1D (line).
quadrature.cell = pylith.feassemble.FIATLagrange
quadrature.cell.dimension = 1

# The slip time and final slip are defined in spatial databases.
[pylithapp.timedependent.interfaces.fault.eq_srcs.rupture.slip_function]
slip.iohandler.filename = eqslip.spatialdb
slip.query_type = linear
slip.label = Final slip

# Slip time is uniform, so use UniformDB for convenience
slip_time = spatialdata.spatialdb.UniformDB
slip_time.label = Slip time
slip_time.values = [slip-time]
slip_time.data = [0.0*year]

# ----------------------------------------------------------------------
# output
# ----------------------------------------------------------------------
# Fault
[pylithapp.problem.interfaces.fault.output]
output_freq = time_step
time_step = 19.99999*year
writer = pylith.meshio.DataWriterHDF5

# ----------------------------------------------------------------------
# Solver
# ----------------------------------------------------------------------
[pylithapp.problem.formulation]
# The split_fields flag must be specified, so that the PCFIELDSPLIT
# preconditioner can be used. The matrix_type must be set to aij since
# we lose symmetry when splitting. We have turned on the custom
# preconditioner for the Lagrange multiplier degrees of freedom.
#
split_fields = True
matrix_type = aij
use_custom_constraint_pc = True

[pylithapp.petsc]
# The displacements are solved with algebraic multigrid (ML), and
# the fault tractions with a standard Krylov method since we do not
# explicitly form the Schur complement matrix.
#
fs_pc_type = fieldsplit
fs_pc_use_amat =
fs_pc_fieldsplit_type = multiplicative
fs_fieldsplit_displacement_pc_type = ml
fs_fieldsplit_lagrange_multiplier_pc_type = jacobi
fs_fieldsplit_displacement_ksp_type = preonly
fs_fieldsplit_lagrange_multiplier_ksp_type = preonly


# End of file
