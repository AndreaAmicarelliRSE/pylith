
\section{\label{sec:Tutorial-3d-tet4}Tutorial Using Tetrahedral Mesh Created
by LaGriT}

PyLith features discussed in this tutorial:
\begin{itemize}
\item Quasi-static solution
\item LaGriT mesh format
\item Dirichlet boundary conditions
\item Kinematic fault interface conditions
\item Linearly elastic isotropic material
\item Maxwell linear viscoelastic material
\item Specifying more than one material
\item VTK output
\item Linear tetrahedral cells
\item SimpleDB spatial database
\item ZeroDispDB spatial database
\item Custom algebraic multigrid preconditioner with split fields
\item Global uniform mesh refinement
\end{itemize}
All of the files necessary to run the examples are contained in the
directory \texttt{examples/3d/tet4.}


\subsection{Overview}

This tutorial is a simple 3D example of a quasi-static finite element
problem. It is a mesh composed of 852 linear tetrahedra subject to
displacement boundary conditions. This example demonstrates the usage
of the LaGriT mesh generation package \url{lagrit.lanl.gov} to create
a mesh, as well as describing how to use a LaGriT-generated mesh in
PyLith. In this tutorial, we will walk through the steps necessary
to construct, run, and visualize the results for two problems that
use the same mesh. For each of these problems we also consider a simulation
using a custom algebraic multigrid preconditioner with a globally
uniformly refined mesh that reduces the node spacing by a factor of
two. In addition to this manual, each of the files for the example
problems includes extensive comments.


\subsection{Mesh Generation and Description}

The mesh for these examples is a simple rectangular prism (Figure
\ref{fig:3dtet4-mesh}). This mesh would be quite difficult to generate
by hand, so we use the LaGriT mesh generation package. For this example,
we provide a documented command file in \texttt{examples/3d/tet4.}
Examination of this command file should provide some insight into
how to use LaGriT with PyLith. For more detailed information refer
to the LaGriT website \url{lagrit.lanl.gov}. If you have LaGriT installed
on your machine, you can use the command file to create your own mesh.
Otherwise, you can use the mesh that has already been created.

There are two ways to use the command file. The simplest method is
to go to the\textsf{ }examples directory (\texttt{}~\linebreak{}
\texttt{examples/3d/tet4}), start LaGriT, and then type:
\begin{lyxcode}
input~mesh\_tet4\_1000m.lagrit
\end{lyxcode}
This will run the commands in that file, which will produce the necessary
files to run the example. This method will create the mesh, but you
will gain very little insight into what is being done. A more informative
approach is to input each command directly. That way, you will see
what each command does. You can simply copy and paste the commands
from \texttt{mesh\_tet4\_1000m.lagrit}. For example, the first six
commands, which define the block shape, are
\begin{lyxcode}
define~/~domain\_xm~/~-3.0e+3

define~/~domain\_xp~/~~3.0e+3

define~/~domain\_ym~/~-3.0e+3

define~/~domain\_yp~/~~3.0e+3

define~/~domain\_zm~/~-4.0e+3

define~/~domain\_zp~/~~0.0e+3~
\end{lyxcode}
Continuing through the remainder of the commands in \texttt{mesh\_tet4\_1000m.lagrit},
you will eventually end up with the files \texttt{tet4\_1000m\_binary.gmv},
\texttt{tet4\_1000m\_ascii.gmv}, \texttt{tet4\_1000m\_ascii.pset},
and \texttt{tet4\_1000m\_binary.pset}. The ASCII files are not actually
needed, but we create them so users can see what is contained in the
files. These files may also be used instead of the binary versions,
if desired. The \texttt{.gmv} files define the mesh information, and
they may be read directly by the GMV \url{laws.lanl.gov/XCM/gmv/GMVHome.html}
mesh visualization package. The \texttt{.pset} files specify the vertices
corresponding to each set of vertices on a surface used in the problem,
including the fault as well as external boundaries to which boundary
conditions are applied.

\noindent \begin{center}
\begin{figure}
\begin{centering}
\includegraphics[scale=0.45]{tutorials/3dtet4/figs/tet4-mesh}
\par\end{centering}

\caption{Mesh composed of linear tetrahedral cells generated by LaGriT used
for the example problems. The different colors represent the different
materials.\label{fig:3dtet4-mesh}}
\end{figure}

\par\end{center}


\subsection{Additional Common Information}

In addition to the mesh, the example problems share additional information.
In such cases it is generally useful to create a file named \texttt{pylithapp.cfg}
in the run directory, since this file is read automatically every
time PyLith is run. Settings specific to a particular problem may
be placed in other \texttt{.cfg} files, as described later, and then
those files are placed on the command line.  The settings contained
in \texttt{pylithapp.cfg} for this problem consist of:
\begin{description}
\item [{pylithapp.journal.info}] Settings that control the verbosity of
the output for the different components.
\item [{pylithapp.mesh\_generator}] Settings that control mesh importing,
such as the importer type, the filenames, and the spatial dimension
of the mesh.
\item [{pylithapp.timedependent}] Settings that control the problem, such
as the total time, time-step size, and number of entries in the material
array.
\item [{pylithapp.timedependent.materials}] Settings that control the material
type, specify which material IDs are to be associated with a particular
material type, and give the name of the spatial database containing
material parameters for the mesh. The quadrature information is also
given.
\item [{pylithapp.petsc}] PETSc settings to use for the problem, such as
the preconditioner type.
\end{description}
Since these examples use a mesh from LaGriT, we set the importer to
\texttt{MeshIOLagrit}:
\begin{lyxcode}
{[}pylithapp.mesh\_generator{]}

reader~=~pylith.meshio.MeshIOLagrit

~

{[}pylithapp.mesh\_generator.reader{]}

filename\_gmv~=~mesh/tet4\_1000m\_binary.gmv

filename\_pset~=~mesh/tet4\_1000m\_binary.pset

flip\_endian~=~True

\#~record\_header\_32bit~=~False
\end{lyxcode}
Notice that there are a couple of settings pertinent to binary files.
The first flag (\texttt{flip\_endian}) is used if the binary files
were produced on a machine with a different endianness than the machine
on which they are being read. If you get an error when attempting
to run an example, you may need to change the setting of this flag.
The second flag (\texttt{record\_header\_32bit}) may need to be set
to \texttt{False} if the version of LaGriT being used has 64-bit Fortran
record headers. 

This example differs from previous examples, because we specify two
material groups:
\begin{lyxcode}
{[}pylithapp.timedependent{]}

materials~=~{[}elastic,viscoelastic{]}

~

{[}pylithapp.timedependent.materials.elastic{]}

label~=~Elastic~material

id~=~1

db.iohandler.filename~=~spatialdb/mat\_elastic.spatialdb

quadrature.cell~=~pylith.feassemble.FIATSimplex

quadrature.cell.dimension~=~3

~

{[}pylithapp.timedependent.materials.viscoelastic{]}

label~=~Viscoelastic~material

id~=~2

db.iohandler.filename~=~spatialdb/mat\_viscoelastic.spatialdb

quadrature.cell~=~pylith.feassemble.FIATSimplex

quadrature.cell.dimension~=~3




\end{lyxcode}
The two materials correspond to the two different colors in Figure
\ref{fig:3dtet4-mesh}. Each material uses a different spatial database
because the physical parameters are different. In generating the mesh
within LaGriT, the mesh contains four materials as a result of how
LaGriT handles materials and interior interfaces. Near the end of
the LaGriT command file, we merge the materials on each side of the
fault into a single material to simplify the input and output from
PyLith. For this example, values describing three-dimensional elastic
material properties are given by the single point in the spatial databases,
resulting in uniform physical properties within each material.


\subsection{Shear Displacement Example}

The first example problem is shearing of the mesh along the y-direction,
with displacement boundary conditions applied on the planes corresponding
to the minimum and maximum x-values. Parameter settings that override
or augment those in \texttt{pylithapp.cfg} are contained in the file
\texttt{step01.cfg}. These settings are:
\begin{description}
\item [{pylithapp.timedependent}] Specifies an implicit formulation for
the problem and specifies the array of boundary conditions.
\item [{pylithapp.timedependent.implicit}] Specifies an array of two output
managers, one for the full domain, and another for a subdomain corresponding
to the ground surface.
\item [{pylithapp.timedependent.bc.x\_pos}] Specifies the boundary conditions
for the right side of the mesh, defining which degrees of freedom
are being constrained (\texttt{x} and \texttt{y}), providing the label
(defined in \texttt{tet4\_1000m\_binary.pset}) defining the points
desired, assigning a label to the boundary condition set, and giving
the name of the spatial database defining the boundary conditions
(\texttt{fixeddisp\_shear.spatialdb}).
\item [{pylithapp.timedependent.bc.x\_neg}] Specifies the boundary conditions
for the left side of the mesh, defining which degrees of freedom are
being constrained (\texttt{x} and \texttt{y}), providing the label
(defined in \texttt{tet4\_1000m\_binary.}pset) defining the points
desired, assigning a label to the boundary condition set, and giving
the name of the spatial database defining the boundary conditions
(\texttt{fixeddisp\_shear.spatialdb}).
\item [{pylithapp.timedependent.bc.z\_neg}] Specifies the boundary conditions
for the bottom of the mesh, defining which degrees of freedom are
being constrained (\texttt{x} and \texttt{y}), providing the label
(defined in \texttt{tet4\_1000m\_binary.}pset) defining the points
desired, assigning a label to the boundary condition set, and giving
the name of the spatial database defining the boundary conditions
(\texttt{fixeddisp\_shear.spatialdb}).
\item [{pylithapp.problem.formulation.output.domain.writer}] Gives the
base filename for VTK output over the entire domain (\texttt{shearxy.vtk}).
\item [{pylithapp.problem.formulation.output.subdomain}] Gives the label
of the nodeset defining the subdomain and gives the base filename
for VTK output over the subdomain corresponding to the ground surface
\linebreak{}
(\texttt{step01-groundsurf.vtk}).
\item [{pylithapp.timedependent.materials.elastic.output}] Gives the base
filename for state variable output files for the \texttt{elastic}
material set (\texttt{step01-elastic.vtk}), and causes state variables
to be averaged over all quadrature points in each cell.
\item [{pylithapp.timedependent.materials.viscoelastic.output}] Gives the
base filename for state variable output files for the \texttt{viscoelastic}
material set (\texttt{step01-viscoelastic.vtk}), and causes state
variables to be averaged over all quadrature points in each cell.
\end{description}
The values for the Dirichlet boundary conditions are described in
the file \texttt{fixeddisp\_shear.spatialdb}, as specified in \texttt{step01.cfg}.
The format of all spatial database files is similar. Because data
are being specified using two control points (rather than being uniform
over the mesh, for example), the data dimension is one.

The files containing common information (\texttt{tet4\_1000m\_binary.gmv,
tet4\_1000m\_binary.pset, }~\linebreak{}
\texttt{pylithapp.cfg, mat\_elastic.spatialdb, and mat\_viscoelastic.spatialdb})
along with the problem-specific files (\texttt{step01.cfg }and\texttt{
fixeddisp\_shear.spatialdb}) provide a complete description of the
problem, and we can then run this example by typing
\begin{lyxcode}
pylith~step01.cfg
\end{lyxcode}
Once the problem has run, six files will be produced. The first file
is named \texttt{step01\_t0000000.vtk}. The \texttt{t0000000} indicates
that the output is for the first (and only) time step, corresponding
to an elastic solution. This file contains mesh information as well
as displacement values at the mesh vertices. The second file is named
\texttt{}~\linebreak{}
\texttt{step01-statevars-elastic\_t0000000.vtk}. This file contains
the state variables for each cell in the material group \texttt{elastic}.
The default fields are the total strain and stress fields. These values
are computed at each quadrature point in the cell. We have requested
that the values be averaged over all quadrature points for each cell;
however, since we only have a single quadrature point for each linear
tetrahedron, this will have no effect. The third file (\texttt{step01-statevars-viscoelastic\_info.vtk})
gives the material properties used for the \texttt{viscoelastic} material
set. Since we have not specified which properties to write, the default
properties (\texttt{mu}, \texttt{lambda}, \texttt{density}) are written.
There are two additional files containing the state variables for
each of the material sets. The final file (\texttt{step01-groundsurf\_t0000000.vtk})
is analogous to \texttt{step01\_t0000000.vtk}, but in this case the
results are only given for a subset of the mesh corresponding to the
ground surface. Also, the cells in this file are one dimension lower
than the cells described in \texttt{step01\_t0000000.vtk}, so they
are triangles rather than tetrahedra. All of the \texttt{.vtk} files
may be used with a number of visualization packages. If the problem
ran correctly, you should be able to generate a figure such as Figure
\ref{fig:3dtet4-shear}, which was generated using ParaView.

\begin{center}
\begin{figure}
\begin{centering}
\includegraphics[scale=0.45]{tutorials/3dtet4/figs/shear}
\par\end{centering}

\caption{Color contours and vectors of displacement for the axial displacement
example using a mesh composed of linear tetrahedral cells generated
by LaGriT.\label{fig:3dtet4-shear}}
\end{figure}

\par\end{center}


\subsubsection{Alternative Solver and Discretization Settings}

Example \texttt{step01.cfg} uses the additive Schwarz preconditioner
in conjunction with a classical Gram-Schmidt orthogonalization iterative
solver. This preconditioner works reasonably well but the number of
iterations generally scales with problem size. Even this small, simple
problem requires 24 iterations. In this example (\texttt{step02.cfg}),
we use a more sophisticated preconditioner that preconditions the
degrees of freedom associated with the displacement field with an
algebraic multigrid algorithm (see Section \ref{sec:petsc:options}
for details). Additionally, we illustrate the use of global uniform
mesh refinement to increase the resolution of the solution by a factor
of two. Because the mesh is refined in parallel after distribution,
this technique can be used to run a larger problem than would be possible
if the full resolution mesh had to be generated by the mesh generator.
LaGriT runs only in serial and CUBIT has extremely limited parallel
mesh generation capabilities. Table \ref{tab:3dtet4:solver:cmp} shows
the improved efficiency of the solver using the split fields with
the algebraic multigrid preconditioner, especially as the problem
size becomes larger. We have found similar results for other problems.

\noindent \begin{center}
\begin{table}[H]
\centering{}\caption{\label{tab:3dtet4:solver:cmp}Number of iterations in linear solve
for the Shear Displacement and Kinematic Fault Slip problems discussed
in this section. The preconditioner using split fields and an algebraic
multigrid algorithm solves the linear system with fewer iterations
with only a small to moderate increase as the problem size grows.}
\begin{tabular}{|>{\centering}p{1.5in}|>{\centering}m{1.25in}|>{\centering}p{1.5in}|>{\centering}p{1in}|}
\hline 
\textbf{Problem} & \textbf{Preconditioner} & \textbf{Refinement} & \textbf{\# Iterations in Solve}\tabularnewline
\hline 
\hline 
\multirow{4}{1.5in}{Shear Displacement} & \multirow{2}{1.25in}{additive Schwarz} & none (546 DOF) & 24 (step01)\tabularnewline
\cline{3-4} 
 &  & 2x refinement

(3890 DOF) & 47\tabularnewline
\cline{2-4} 
 & \multirow{2}{1.25in}{split fields with algebraic multigrid} & none (546 DOF) & 13\tabularnewline
\cline{3-4} 
 &  & 2x refinement

(3890 DOF) & 28 (step02)\tabularnewline
\hline 
\multirow{4}{1.5in}{Kinematic Fault Slip} & \multirow{2}{1.25in}{additive Schwarz} & none (735 DOF) & 28 (step03)\tabularnewline
\cline{3-4} 
 &  & 2x refinement

(4527 DOF) & 63\tabularnewline
\cline{2-4} 
 & \multirow{2}{1.25in}{split fields with algebraic multigrid} & none (735 DOF) & 28\tabularnewline
\cline{3-4} 
 &  & 2x refinement

(4527 DOF) & 38 (step04)\tabularnewline
\hline 
\end{tabular}
\end{table}

\par\end{center}

The field splitting and algebraic multigrid preconditioning are set
up in \texttt{step02.cfg} with the following parameters:
\begin{lyxcode}
{[}pylithapp.timedependent.formulation{]}

matrix\_type~=~aij



{[}pylithapp.petsc{]}

pc\_type~=~ml
\end{lyxcode}
The uniform global refinement requires changing just a single parameter:
\begin{lyxcode}
{[}pylithapp.mesh\_generator{]}

refiner~=~pylith.topology.RefineUniform
\end{lyxcode}

\subsection{Kinematic Fault Slip Example}

The next example problem is a right-lateral fault slip applied on
the vertical fault defined by \texttt{x = 0}. The left and right sides
of the mesh are fixed in the \texttt{x}, \texttt{y}, and \texttt{z}
directions. Parameter settings that override or augment those in \texttt{pylithapp.cfg}
are contained in the file \texttt{step03.cfg}. These settings are:
\begin{description}
\item [{pylithapp.timedependent}] Specifies an implicit formulation for
the problem, the array of boundary conditions, and the array of interfaces.
\item [{pylithapp.timedependent.implicit}] Specifies an array of two output
managers, one for the full domain, and another for a subdomain corresponding
to the ground surface.
\item [{pylithapp.timedependent.bc.x\_pos}] Specifies the boundary conditions
for the right side of the mesh, defining which degrees of freedom
are being constrained (\texttt{x}, \texttt{y}, and \texttt{z}), providing
the label (defined in \texttt{tet4\_1000m\_binary.pset}) defining
the points desired, and assigning a label to the boundary condition
set. Rather than specifying a spatial database file to define the
boundary conditions, we use the default spatial database (ZeroDispDB)
for the Dirichlet boundary condition, which sets the displacements
to zero.
\item [{pylithapp.timedependent.bc.x\_neg}] Specifies the boundary conditions
for the left side of the mesh, defining which degrees of freedom are
being constrained (\texttt{x}, \texttt{y}, and \texttt{z}), providing
the label (defined in \texttt{tet4\_1000m\_binary.pset}) defining
the points desired, and assigning a label to the boundary condition
set. Rather than specifying a spatial database file to define the
boundary conditions, we use the default spatial database (ZeroDispDB)
for the Dirichlet boundary condition, which sets the displacements
to zero.
\item [{pylithapp.timedependent.interfaces}] Gives the label (defined in
\texttt{tet4\_1000m\_binary.pset}) defining the points on the fault,
provides quadrature information, and then gives database names for
material properties (needed for conditioning), fault slip, peak fault
slip rate, and fault slip time.
\item [{pylithapp.problem.formulation.output.output.writer}] Gives the
base filename for VTK output over the entire domain (\texttt{step03.vtk}).
\item [{pylithapp.problem.formulation.output.subdomain}] Gives the label
of the nodeset defining the subdomain and gives the base filename
for VTK output over the subdomain corresponding to the ground surface
\linebreak{}
(\texttt{step03-groundsurf.vtk}).
\item [{pylithapp.timedependent.interfaces.fault.output.writer}] Gives
the base filename for cohesive cell output files \linebreak{}
(\texttt{step03-fault.vtk}).
\item [{pylithapp.timedependent.materials.elastic.output}] Gives the base
filename for state variable output files for the \texttt{elastic}
material set (\texttt{step03-statevars-elastic.vtk}), and causes state
variables to be averaged over all quadrature points in each cell.
\item [{pylithapp.timedependent.materials.viscoelastic.output}] Gives the
base filename for state variable output files for the \texttt{viscoelastic}
material set (\texttt{step03-statevars-viscoelastic.vtk}), and causes
state variables to be averaged over all quadrature points in each
cell.
\end{description}
The fault example requires three additional database files that were
not needed for the simple displacement example. The first file (\texttt{finalslip.spatialdb})
specifies a constant value of 2 m of right-lateral fault slip that
then tapers linearly to zero from 2 km to 4 km depth, and a linearly-varying
amount of reverse slip, with a maximum of 0.25 m at the surface, linearly
tapering to 0 m at 2 km depth. The data dimension is one since the
data vary linearly along a vertical line. The default slip time function
is a step-function, so we also must provide the time at which slip
begins. The elastic solution is associated with advancing from $t=-dt$
to $t=0$, so we set the slip initiation time for the step-function
to 0 in \texttt{dislocation\_sliptime.spatialdb}.

The files containing common information (\texttt{\small{}tet4\_1000m\_binary.gmv}{\small{},
}\texttt{\small{}tet4\_1000m\_binary.pset}{\small{}, }\texttt{\small{}pylithapp.cfg}{\small{},
}\texttt{\small{}mat\_elastic.spatialdb}, and \texttt{mat\_viscoelastic.spatialdb})
along with the problem-specific files (\texttt{\small{}step03.cfg}{\small{},
}\texttt{\small{}finalslip.spatialdb}{\small{}, and }\texttt{\small{}sliptime.spatialdb})
provide a complete description of the problem, and we can then run
this example by typing
\begin{lyxcode}
pylith~step03.cfg
\end{lyxcode}
Once the problem has run, eight files will be produced. The first
file is named \texttt{step03\_t0000000.vtk}. The \texttt{t0000000}
indicates that the output is for the first (and only) time step, corresponding
to an elastic solution. This file contains mesh information as well
as displacement values at the mesh vertices. The second file is named
\texttt{}~\linebreak{}
\texttt{step03-statevars-elastic\_t0000000.vtk}. This file contains
the state variables for each cell in the material group \texttt{elastic}.
The default fields are the total strain and stress fields. We have
requested that the values be averaged over all quadrature points for
each cell; however, since we only have a single quadrature point for
each linear tetrahedron, this will have no effect. The third file
(\texttt{step03-statevars-viscoelastic\_info.vtk}) gives the material
properties used for the \texttt{viscoelastic} material set. Since
we have not specified which properties to write, the default properties
(\texttt{mu}, \texttt{lambda}, \texttt{density}) are written. There
are two additional files containing the state variables for each of
the material sets. The file \texttt{step03-groundsurf\_t0000000.vtk}
is analogous to \texttt{step03\_t0000000.vtk}, but in this case the
results are only given for a subset of the mesh corresponding to the
ground surface. Also, the cells in this file are one dimension lower
than the cells described in \texttt{step03\_t0000000.vtk}, so they
are triangles rather than tetrahedra. The file \texttt{step03-fault\_t0000000.vtk}
gives the specified fault slip for each vertex on the fault, along
with the computed traction change for the cohesive cell. The final
file, \texttt{step03-fault\_info.vtk}, provides information such as
the normal direction, final slip, and slip time for each vertex on
the fault. All of the \texttt{.vtk} files may be used with a number
of visualization packages. If the problem ran correctly, you should
be able to generate a figure such as Figure\vref{fig:3dtet-disloc},
which was generated using ParaView.

\noindent \begin{center}
\begin{figure}
\begin{centering}
\includegraphics[scale=0.45]{tutorials/3dtet4/figs/dislocation}
\par\end{centering}

\caption{Color contours and vectors of displacement for the kinematic fault
example using a mesh composed of linear tetrahedral cells generated
by LaGriT.\label{fig:3dtet-disloc}}
\end{figure}

\par\end{center}


\subsubsection{Alternative Solver and Discretization Settings}

As we did for the Shear Dislocation examples, in \texttt{step04.cfg}
we switch to using the split fields and algebraic multigrid preconditioner
along with global uniform mesh refinement. Because PyLith implements
fault slip using Lagrange multipliers, we make a few small adjusments
to the solver settings. As discussed in Section \ref{sec:petsc:options},
we use a custom preconditioner for the Lagrange multiplier degrees
of freedom when preconditioning with field splitting. Within \texttt{step04.cfg}
we turn on the use of the custom preconditioner for the Lagrange multiplier
degrees of freedom and add the corresponding settings for the fourth
field for the algebraic multigrid algorithm,
\begin{lyxcode}
{[}pylithapp.timedependent.formulation{]}

split\_fields~=~True

use\_custom\_constraint\_pc~=~True

matrix\_type~=~aij



{[}pylithapp.petsc{]}

fs\_pc\_type~=~fieldsplit

fs\_pc\_use\_amat~=~true

fs\_pc\_fieldsplit\_type~=~multiplicative

fs\_fieldsplit\_displacement\_pc\_type~=~ml

fs\_fieldsplit\_lagrange\_multiplier\_pc\_type~=~jacobi

fs\_fieldsplit\_displacement\_ksp\_type~=~preonly

fs\_fieldsplit\_lagrange\_multiplier\_ksp\_type~=~preonly
\end{lyxcode}
Table \ref{tab:3dtet4:solver:cmp} shows the improved efficiency of
the solver using the split fields with the algebraic multigrid preconditioner.
